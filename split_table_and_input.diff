diff --git a/halo2_proofs/src/plonk/circuit.rs b/halo2_proofs/src/plonk/circuit.rs
index 3c41cf27..27363bff 100644
--- a/halo2_proofs/src/plonk/circuit.rs
+++ b/halo2_proofs/src/plonk/circuit.rs
@@ -442,7 +442,7 @@ pub trait Circuit<F: Field> {
 }
 
 /// Low-degree expression representing an identity that must hold over the committed columns.
-#[derive(Clone, Debug)]
+#[derive(Clone, Debug, PartialEq, Eq)]
 pub enum Expression<F> {
     /// This is a constant polynomial
     Constant(F),
@@ -788,6 +788,42 @@ impl<F: Field> Gate<F> {
     }
 }
 
+#[derive(Default, Debug, Clone)]
+pub struct Lookups<F: Field> {
+    lookups: Vec<lookup::Argument<F>>,
+    lookup_tables: lookup::LookupTables<F>,
+}
+
+impl<F: Field> Lookups<F> {
+    pub fn add(&mut self, name:  &'static str, input_expressions: Vec<Expression<F>>, table_expressions: Vec<Expression<F>>) {
+
+        assert_eq!(input_expressions.len(), table_expressions.len());
+        let table_idx = self.lookup_tables.get_idx_of_table_expr(&table_expressions);
+        self.lookups.push(lookup::Argument::new(name, input_expressions, table_idx))
+    }
+    pub fn required_degree(&self) -> usize {
+        let mut d = 0;
+        for l in &self.lookups {
+            let mut input_degree = 1;
+        for expr in l.input_expressions.iter() {
+            input_degree = std::cmp::max(input_degree, expr.degree());
+        }
+        let mut table_degree = 1;
+        for expr in self.lookup_tables.tables[l.table_idx].iter() {
+            table_degree = std::cmp::max(table_degree, expr.degree());
+        }
+        let d1 = std::cmp::max(
+            // (1 - (l_last + l_blind)) z(\omega X) (a'(X) + \beta) (s'(X) + \gamma)
+            4,
+            // (1 - (l_last + l_blind)) z(X) (\theta^{m-1} a_0(X) + ... + a_{m-1}(X) + \beta) (\theta^{m-1} s_0(X) + ... + s_{m-1}(X) + \gamma)
+            2 + input_degree + table_degree,
+        );
+        d = std::cmp::max(d1, d)
+    }
+    d
+}
+}
+
 /// This is a description of the circuit environment, such as the gate, column and
 /// permutation arrangements.
 #[derive(Debug, Clone)]
@@ -811,7 +847,7 @@ pub struct ConstraintSystem<F: Field> {
 
     // Vector of lookup arguments, where each corresponds to a sequence of
     // input expressions and a sequence of table expressions involved in the lookup.
-    pub(crate) lookups: Vec<lookup::Argument<F>>,
+    pub(crate) lookups: Lookups<F>,
 
     // Vector of fixed columns, which can be used to store constant values
     // that are copied into advice columns.
@@ -834,7 +870,7 @@ pub struct PinnedConstraintSystem<'a, F: Field> {
     instance_queries: &'a Vec<(Column<Instance>, Rotation)>,
     fixed_queries: &'a Vec<(Column<Fixed>, Rotation)>,
     permutation: &'a permutation::Argument,
-    lookups: &'a Vec<lookup::Argument<F>>,
+    lookups: &'a Lookups<F>,
     constants: &'a Vec<Column<Fixed>>,
     minimum_degree: &'a Option<usize>,
 }
@@ -863,7 +899,7 @@ impl<F: Field> Default for ConstraintSystem<F> {
             num_advice_queries: Vec::new(),
             instance_queries: Vec::new(),
             permutation: permutation::Argument::new(),
-            lookups: Vec::new(),
+            lookups: Default::default(),
             constants: vec![],
             minimum_degree: None,
         }
@@ -921,7 +957,7 @@ impl<F: Field> ConstraintSystem<F> {
         table_map: impl FnOnce(&mut VirtualCells<'_, F>) -> Vec<(Expression<F>, TableColumn)>,
     ) -> usize {
         let mut cells = VirtualCells::new(self);
-        let table_map = table_map(&mut cells)
+        let (inputs, table): (Vec<Expression<F>>, Vec<Expression<F>>) = table_map(&mut cells)
             .into_iter()
             .map(|(input, table)| {
                 if input.contains_simple_selector() {
@@ -931,12 +967,11 @@ impl<F: Field> ConstraintSystem<F> {
                 let table = cells.query_fixed(table.inner(), Rotation::cur());
 
                 (input, table)
-            })
-            .collect();
+            }).unzip();
 
-        let index = self.lookups.len();
+        let index = self.lookups.lookups.len();
 
-        self.lookups.push(lookup::Argument::new(name, table_map));
+        self.lookups.add(name, inputs, table);
 
         index
     }
@@ -953,12 +988,11 @@ impl<F: Field> ConstraintSystem<F> {
         table_map: impl FnOnce(&mut VirtualCells<'_, F>) -> Vec<(Expression<F>, Expression<F>)>,
     ) -> usize {
         let mut cells = VirtualCells::new(self);
-        let table_map = table_map(&mut cells);
+        let (inputs, table): (Vec<Expression<F>>, Vec<Expression<F>>) = table_map(&mut cells).into_iter().unzip();
+        let index = self.lookups.lookups.len();
 
-        let index = self.lookups.len();
-
-        self.lookups.push(lookup::Argument::new(name, table_map));
 
+        self.lookups.add(name, inputs, table);
         index
     }
 
@@ -1220,12 +1254,13 @@ impl<F: Field> ConstraintSystem<F> {
 
         // Substitute non-simple selectors for the real fixed columns in all
         // lookup expressions
-        for expr in self.lookups.iter_mut().flat_map(|lookup| {
+        for expr in self.lookups.lookups.iter_mut().flat_map(|lookup| {
             lookup
                 .input_expressions
                 .iter_mut()
-                .chain(lookup.table_expressions.iter_mut())
-        }) {
+        })
+                .chain(self.lookups.lookup_tables.tables.iter_mut().flat_map(|t|t.iter_mut()))
+         {
             replace_selectors(expr, &selector_replacements, true);
         }
 
@@ -1297,14 +1332,7 @@ impl<F: Field> ConstraintSystem<F> {
 
         // The lookup argument also serves alongside the gates and must be accounted
         // for.
-        degree = std::cmp::max(
-            degree,
-            self.lookups
-                .iter()
-                .map(|l| l.required_degree())
-                .max()
-                .unwrap_or(1),
-        );
+        degree = self.lookups.required_degree();
 
         // Account for each gate to ensure our quotient polynomial is the
         // correct degree and that our extended domain is the right size.
diff --git a/halo2_proofs/src/plonk/lookup.rs b/halo2_proofs/src/plonk/lookup.rs
index b7f97042..e31d46b7 100644
--- a/halo2_proofs/src/plonk/lookup.rs
+++ b/halo2_proofs/src/plonk/lookup.rs
@@ -8,24 +8,40 @@ pub(crate) mod verifier;
 pub(crate) struct Argument<F: Field> {
     pub name: &'static str,
     pub input_expressions: Vec<Expression<F>>,
-    pub table_expressions: Vec<Expression<F>>,
+    pub table_idx: usize,
+    //pub table_expressions: Vec<Expression<F>>,
+}
+
+#[derive(Default, Debug, Clone)]
+pub struct LookupTables<F: Field> {
+    pub tables: Vec<Vec<Expression<F>>>,
+}
+
+impl<F: Field> LookupTables<F> {
+    pub fn get_idx_of_table_expr(&mut self, table: &Vec<Expression<F>>) -> usize {
+        for (i, t) in self.tables.iter().enumerate() {
+            if table == t {
+                return i
+            }
+        }
+        self.tables.push(table.clone());
+        self.tables.len() - 1
+    }
 }
 
 impl<F: Field> Argument<F> {
     /// Constructs a new lookup argument.
     ///
     /// `table_map` is a sequence of `(input, table)` tuples.
-    pub fn new(name: &'static str, table_map: Vec<(Expression<F>, Expression<F>)>) -> Self {
-        let (input_expressions, table_expressions) = table_map.into_iter().unzip();
+    pub fn new(name: &'static str, input_expressions: Vec<Expression<F>>, table_idx: usize) -> Self {
         Argument {
             name,
             input_expressions,
-            table_expressions,
+            table_idx,
         }
     }
 
     pub(crate) fn required_degree(&self) -> usize {
-        assert_eq!(self.input_expressions.len(), self.table_expressions.len());
 
         // The first value in the permutation poly should be one.
         // degree 2:
@@ -55,10 +71,10 @@ impl<F: Field> Argument<F> {
         for expr in self.input_expressions.iter() {
             input_degree = std::cmp::max(input_degree, expr.degree());
         }
-        let mut table_degree = 1;
-        for expr in self.table_expressions.iter() {
-            table_degree = std::cmp::max(table_degree, expr.degree());
-        }
+        //let mut table_degree = 1;
+        //for expr in self.table_expressions.iter() {
+        //    table_degree = std::cmp::max(table_degree, expr.degree());
+        //}
 
         // In practice because input_degree and table_degree are initialized to
         // one, the latter half of this max() invocation is at least 4 always,
@@ -68,7 +84,7 @@ impl<F: Field> Argument<F> {
             // (1 - (l_last + l_blind)) z(\omega X) (a'(X) + \beta) (s'(X) + \gamma)
             4,
             // (1 - (l_last + l_blind)) z(X) (\theta^{m-1} a_0(X) + ... + a_{m-1}(X) + \beta) (\theta^{m-1} s_0(X) + ... + s_{m-1}(X) + \gamma)
-            2 + input_degree + table_degree,
+            2 + input_degree/*  + table_degree*/,
         )
     }
 }
